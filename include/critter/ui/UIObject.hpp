#ifndef UI_OBJECT_H_
#define UI_OBJECT_H_

#include <glad/glad.h>

#include <glm/glm.hpp>

#include <critter/GameObject.hpp>
#include <shader/Canvas.hpp>
#include <shader/Framebuffer.hpp>
#include <shader/materials/TextureXferMaterial.hpp>
#include <input/MouseEvent.hpp>
#include <model/Mesh.hpp>

#include <atomic>
#include <mutex>

namespace monkeysworld {
namespace critter {
namespace ui {

class UIGroup;

/**
 *  UI Objects are objects which display on top of the rendered window, typically as 2D components.
 * 
 *  UI objects are grouped together, and are positioned relative to their containers.
 *  
 */ 
class UIObject : public Object, public std::enable_shared_from_this<UIObject> {
  // quick hack lol
  friend class UIGroup;
 public:
  
  UIObject(engine::Context* ctx);
  void Accept(Visitor& v) override;

  /**
   *  Returns a nullptr in all cases.
   */ 
  std::shared_ptr<Object> GetChild(uint64_t id) override;

  /**
   *  Returns an empty vector in all cases.
   */ 
  std::vector<std::shared_ptr<Object>> GetChildren() override;

  /**
   *  Returns parent of this component.
   */ 
  std::shared_ptr<Object> GetParent() override;

  /**
   *  Accepts incoming click events, and dispatches click events to children.
   *  TODO: Create "MouseEvent" to pass in as params to this and OnClick.
   * 
   *  @param e - a mouse event generated by a cursor event inside this UI object.
   *  @returns true if this UIObject's OnClick method consumed the event,
   *           false otherwise.
   */ 
  bool HandleClickEvent(input::MouseEvent& e);

  /**
   *  Called whenever a click falls in this UI object's screen region.
   *  Overridden by inheriting clients.
   *  @returns true if this UIObject consumes the event, preventing it from
   *           passing further down the UI hierarchy.
   *           if false, event continues down.
   */
  virtual bool OnClick(const input::MouseEvent& e) { 
    BOOST_LOG_TRIVIAL(trace) << "clickity: x = " << e.local_pos.x << ", y = " << e.local_pos.y;
    return false; 
  };

  /**
   *  Returns the position of this object relative to its parent, in XY coords.
   */ 
  glm::vec2 GetPosition() const;

  /**
   *  Sets the position of this UI object.
   *  @param pos - the X/Y coords for this UIObject, relative to parent.
   */ 
  void SetPosition(glm::vec2 pos);

  /**
   *  @returns the absolute position, in xy coords, of this object, from top left.
   */ 
  glm::vec2 GetAbsolutePosition() const;

  /**
   *  @returns the XY size of this UI object.
   */ 
  glm::vec2 GetDimensions() const;

  /**
   *  Sets the size of this UI object.
   *  @param size - the size of the UIObject, in pixels wide/tall.
   */ 
  void SetDimensions(glm::vec2 size);

  /**
   *  Sets the current opacity of this UIObject.
   *  @param opac - the new opacity of the UIObject, clipped to the range [0.0f, 1.0f].
   */ 
  void SetOpacity(float opac);

  /**
   *  @returns the current opacity of this object.
   */ 
  float GetOpacity();

  // nop on this (deprecated)
  void PrepareAttributes() override {}

  /**
   *  Binds the framebuffer associated with this UI object and draws it to the screen.
   *  Calls DrawUI if the UI element has been invalidated by another call.
   */ 
  void RenderMaterial(const engine::RenderContext& rc) override;

  /**
   *  Draws the contents of this framebuffer directly to the screen.
   */ 
  void DrawToScreen();

  // also deprecated
  void Draw() override {}

  /**
   *  Defined by implementors.
   *  
   *  Prior to calling DrawUI, this UIObject will bind its associated framebuffer.
   *  The implementor then defines DrawUI to fill this framebuffer, before its parent
   *  group will then use the framebuffer's color attachment to draw the component to the screen.
   * 
   *  This function will only be called if a UIObject has been invalidated.
   * 
   *  The framebuffer's dimensions can be accessed with "GetDimensions."
   *    Note that draw calls to the framebuffer will use clip space coordinates,
   *    so it is the implementor's responsibility to use commands which take this into account,
   *    or to define functionality which converts it to a more convenient clip space,
   *    for instance by using the resolution to transform components in-shader.
   *  
   *  The parameters to this method represent the minimally invalidated bounding box
   *  for this component -- implementors can use these args to save performance
   *  by only updating a part of the screen, instead of the whole thing. This only really applies
   *  to groups, so do what you want, for the most part.
   * 
   *  @param minXY, the minXY of the invalid bounding box, origin top left.
   *  @param maxXY, the maxXY of the invalid bounding box, origin top left.
   *  @param canvas, an object which enables the implementor to draw basic primitives onto the screen.
   */ 
  virtual void DrawUI(glm::vec2 minXY, glm::vec2 maxXY, shader::Canvas canvas) = 0;

  // TODO: add opacity to here

  /**
   *  Invalidates the framebuffer, notifying the UIObject
   *  to redraw the UI component on the next render pass.
   */ 
  void Invalidate();

  /**
   *  @returns the descriptor for the color attachment to our UI framebuffer.
   */ 
  GLuint GetFramebufferColor();

  /**
   *  @returns the descriptor for our framebuffer as a whole.
   */ 
  GLuint GetFramebuffer();

  UIObject(const UIObject& other);
  UIObject& operator=(const UIObject& other);
  UIObject(UIObject&& other);
  UIObject& operator=(UIObject&& other);
  ~UIObject();

 protected:

  /**
   *  @returns true if the UIObject is still valid, false otherwise.
   */ 
  bool IsValid();

 private:
  std::weak_ptr<UIObject> parent_;                      // parent object if valid
  glm::vec2 pos_;                                       // offset of this component relative to parent
  glm::vec2 size_;                                      // size of ui object, pixels wide/tall
  std::atomic_bool valid_;                              // whether or not the view has been invalidated.
  float opacity_;

  std::shared_ptr<shader::Framebuffer> fb_;

  glm::vec2 fb_size_;                                   // last framebuffer size

  static std::weak_ptr<shader::materials::TextureXferMaterial> xfer_mat_singleton_; 
  static std::mutex xfer_lock_;
  static model::Mesh<storage::VertexPacket2D> xfer_mesh_;

  std::shared_ptr<shader::materials::TextureXferMaterial> xfer_mat_;

  /**
   *  Calculates the minimal bounding box which needs to be updated.
   *  @param xyMin - output parameter for min XY
   *  @param xyMax - output parameter for max XY
   */ 
  void GetInvalidatedBoundingBox(glm::vec2* xyMin, glm::vec2* xyMax);
};

}
}
}

#endif