#ifndef WINDOW_EVENT_MANAGER_H_
#define WINDOW_EVENT_MANAGER_H_

#define GLFW_INCLUDE_NONE
#include <GLFW/glfw3.h>

#include <cinttypes>
#include <functional>
#include <unordered_map>

#include <shared_mutex>
#include <memory>

#include <utils/IDGenerator.hpp>

#include <input/Cursor.hpp>
#include <input/MouseEvent.hpp>

#include <input/ClickListener.hpp>
#include <input/KeyListener.hpp>

namespace monkeysworld {
namespace engine {
class Context;
class EngineContext;
}
}

namespace monkeysworld {
namespace input {

/**
 *  Stores callbacks, and provides locking access to them.
 */ 
struct key_callback_info {
  std::unordered_map<uint64_t, std::function<void(int, int, int)>> callbacks;    // maps descriptors to functions
  std::shared_timed_mutex set_lock;                                              // lock associated with struct scope
};

/**
 *  Stores info on a single event.
 *  REUSE this structure for mouse
 */ 
struct event_info {
  GLFWwindow* window;
  int key;
  int scancode;
  int action;
  int mods;
};


// TODO: expand the `event_info` param to account for a multitude of data types
// TODO: Add a function which polls for character events, instead of keys.
//       ALT: character events are undeniably associated with being focus...
//            we could have getting focus require a character callback,
//            and then call that callback each time

// TODO: Add a "Focus(obj)" method to get focus, and a "GetFocused()" method to see who's focused.

/**
 *  Integrates with GLFW to allow components to listen to input updates.
 *  Events are stored as they arrive, then processed in order when
 *  `ProcessWaitingEvents` is called. Most likely, this should be
 *  called once per frame, after `glfwPollEvents` is called.
 */ 
class WindowEventManager {
  // TODO: factor this out later :(
  friend class ::monkeysworld::engine::EngineContext;
 public:

  /**
   * Creates a new window manager.
   */ 
  WindowEventManager(GLFWwindow* window, engine::Context* ctx);

  /**
   *  @returns a ptr to the active cursor object.
   */ 
  std::shared_ptr<Cursor> GetCursor();
  
  /**
   *  Handles incoming GLFW events.
   *  TODO: Commands should receive a reference to context. Only makes sense! :)
   */ 
  void GenerateKeyEvent(GLFWwindow* window, int key, int scancode, int action, int mods);

  /**
   * Register a listener which will be called when an event is generated for the desired key.
   * @param key - The GLFW integer associated with the desired key.
   * @param callback - The callback which will be invoked when the respective event is invoked.
   *                   Callbacks must return void, and must accept three parameters:
   *                     - int: the GLFW identifier for the key which generated the event (see below, and https://www.glfw.org/docs/3.3.2/group__keys.html)
   *                     - int: the GLFW action associated with the event (see https://www.glfw.org/docs/3.3.2/group__input.html)
   *                     - int: Any key modifiers (see https://www.glfw.org/docs/3.3.2/group__mods.html)
   * @returns a uniquely identifying "event descriptor" which can be used to modify the event later.
   * (deprecated)
   */  
  uint64_t RegisterKeyListener(int key, std::function<void(int, int, int)> callback);
  KeyListener CreateKeyListener(int key, std::function<void(int, int, int)> callback);

  /**
   *  Register a listener which will be called when an event is generated by the mouse.
   *  @param callback - The callback which will be invoked when a mouse event occurs.
   *                    Callbacks must not return anything, and must accept a single parameter:
   *                      - MouseEvent: a struct representing the incoming mouse event.
   *  @returns a uniquely identifying "event descriptor" which can be used to modify the event later.
   *  (deprecated)
   */ 
  uint64_t RegisterClickListener(std::function<void(MouseEvent)> callback);
  ClickListener CreateClickListener(std::function<void(MouseEvent)> callback);


  /**
   * Removes the key listener associated with the provided event descriptor.
   * @param event_id - the ID of the event we wish to remove.
   * @returns true if the event was removed successfully -- false otherwise.
   */ 
  bool RemoveKeyListener(uint64_t event_id);
  void RemoveKeyListener(KeyListener& k);

  /**
   *  Removes a click listener associated with the provided descriptor.
   *  @param event_id - the ID of the callback we wish to remove.
   *  @returns true if the callback was removed -- false otherwise.
   */ 
  bool RemoveClickListener(uint64_t event_id);
  void RemoveClickListener(ClickListener& c);

  // /**
  //  *  Immediately returns the current state of the provided key.
  //  *  @param key - GLFW key code.
  //  */ 
  // int GetKey(int key);
 private:
  // generates a click event
  void GenerateClickEvent(GLFWwindow* window, int click, int action, int mods);

  // maps keycodes to callback sets
  std::unordered_map<int, std::shared_ptr<key_callback_info>> callbacks_;

  // maps event descriptors to key codes
  std::unordered_map<uint64_t, int> callback_to_key_;

  std::unordered_map<uint64_t, std::function<void(MouseEvent)>> mouse_callbacks_;

  // TODO: add functions for requesting focus from the event manager

  // lock for class scope fields
  std::shared_timed_mutex callback_mutex_;

  // generates new events
  static utils::IDGenerator event_desc_generator_;

  // stores incoming events so that they can be processed at once.
  std::vector<event_info> event_queue_;

  // lock for event queue
  std::shared_timed_mutex event_mutex_;

  // ptr to cursor object
  std::shared_ptr<Cursor> cursor_;

  // ptr to context
  engine::Context* ctx_;

  // ptr to active window
  GLFWwindow* window_;
 protected:

    /**
   *  Process all waiting events.
   */  
  void ProcessWaitingEvents();

  /**
   *  Protected ctor for testing purposes.
   *  Tests should subclass this object and then define a nop ctor which uses this.
   *  Please don't fuck with it
   */ 
  WindowEventManager() {};

};

} // namespace input
} // namespace monkeysworld

#endif  // WINDOW_EVENT_MANAGER_H_